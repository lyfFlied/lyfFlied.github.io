<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GIGO一面面经</title>
      <link href="/2019/09/02/GIGO%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
      <url>/2019/09/02/GIGO%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="BIGO一面面经"><a href="#BIGO一面面经" class="headerlink" title="BIGO一面面经"></a>BIGO一面面经</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="vue的特点"><a href="#vue的特点" class="headerlink" title="vue的特点"></a>vue的特点</h2><h2 id="vue双向绑定怎么实现的"><a href="#vue双向绑定怎么实现的" class="headerlink" title="vue双向绑定怎么实现的"></a>vue双向绑定怎么实现的</h2><h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><h2 id="浏览器加载页面的全过程"><a href="#浏览器加载页面的全过程" class="headerlink" title="浏览器加载页面的全过程"></a>浏览器加载页面的全过程</h2><p>DNS解析：把域名解析成IP地址<br>TCP 建立连接：TCP三次握手<br>发送HTTP请求<br>服务器处理并响应报文<br>浏览器解析并渲染页面<br>断开连接：TCP 结束连接  </p><h2 id="做了两道题，输出是什么（关于变量声明提前和引用类型修改值的）"><a href="#做了两道题，输出是什么（关于变量声明提前和引用类型修改值的）" class="headerlink" title="做了两道题，输出是什么（关于变量声明提前和引用类型修改值的）"></a>做了两道题，输出是什么（关于变量声明提前和引用类型修改值的）</h2><pre><code>var name = &apos;weihui&apos;;(function () {    if (typeof name === &apos;undefined&apos;) {        var name = &apos;bigo&apos;;        console.log(&apos;good &apos; + name);    } else {        console.log(&apos;Hello &apos; + name);    }})();//good bigo</code></pre><h2 id="平时怎么学习的"><a href="#平时怎么学习的" class="headerlink" title="平时怎么学习的"></a>平时怎么学习的</h2><h2 id="看过哪些书"><a href="#看过哪些书" class="headerlink" title="看过哪些书"></a>看过哪些书</h2><h2 id="了解我们公司吗"><a href="#了解我们公司吗" class="headerlink" title="了解我们公司吗"></a>了解我们公司吗</h2><h2 id="我们公司是做直播的，了解关于直播的开发吗？"><a href="#我们公司是做直播的，了解关于直播的开发吗？" class="headerlink" title="我们公司是做直播的，了解关于直播的开发吗？"></a>我们公司是做直播的，了解关于直播的开发吗？</h2><h2 id="对未来有什么打算"><a href="#对未来有什么打算" class="headerlink" title="对未来有什么打算"></a>对未来有什么打算</h2><h2 id="觉得自己学前端的优势是什么"><a href="#觉得自己学前端的优势是什么" class="headerlink" title="觉得自己学前端的优势是什么"></a>觉得自己学前端的优势是什么</h2><h2 id="有什么要问的吗"><a href="#有什么要问的吗" class="headerlink" title="有什么要问的吗"></a>有什么要问的吗</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP笔记</title>
      <link href="/2019/09/02/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/02/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h1><h2 id="第1章-了解Web及网络基础"><a href="#第1章-了解Web及网络基础" class="headerlink" title="第1章 了解Web及网络基础"></a>第1章 了解Web及网络基础</h2><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>决定了向用户提供应用服务时通信的活动    </p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul><li>提供处于网络连接中的两台计算机之间的数据传输</li><li>两个协议:TCP、UDP     </li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>处理网络上流动的数据包    </li><li>数据包是网络传输中的最小数据单位  </li><li>在众多的选择内选择一条传输路线</li></ul><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul><li>用来处理连接网络的硬件部分，包括操作系统、硬件的设备驱动、NIC、光纤等。</li></ul><h4 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h4><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http010.png" alt="传输流程"></p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http013.png" alt="TCP三次握手" title="TCP三次握手">  </p><p><strong>SYN</strong>：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。<br><strong>ACK</strong> (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。  </p><ol><li>客户端发送一个携带SYN标志位的包，请求建立连接。</li><li>服务器响应一个携带SYN和ACK标志位的包，同意建立连接。</li><li>客户端再发送一个携带ACK标志位的包，表示连接成功，开始进行数据传输。</li></ol><h2 id="第2章-简单的HTTP协议"><a href="#第2章-简单的HTTP协议" class="headerlink" title="第2章 简单的HTTP协议"></a>第2章 简单的HTTP协议</h2><h3 id="请求报文的构成（P23）"><a href="#请求报文的构成（P23）" class="headerlink" title="请求报文的构成（P23）"></a>请求报文的构成（P23）</h3><p>请求方法、请求URI、请求版本、可选的请求首部字段、内容实体。  </p><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http024.png" alt="请求报文">  </p><h3 id="响应报文的构成"><a href="#响应报文的构成" class="headerlink" title="响应报文的构成"></a>响应报文的构成</h3><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http025.png" alt="响应报文">  </p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>只要任意一端没有明确提出要断开连接，就保持TCP连接状态。  </p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http038.png" alt="cookie">  </p><h2 id="第3章-HTTP报文中的HTTP信息"><a href="#第3章-HTTP报文中的HTTP信息" class="headerlink" title="第3章 HTTP报文中的HTTP信息"></a>第3章 HTTP报文中的HTTP信息</h2><h2 id="第4章-返回结果的HTTP状态"><a href="#第4章-返回结果的HTTP状态" class="headerlink" title="第4章 返回结果的HTTP状态"></a>第4章 返回结果的HTTP状态</h2><h3 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h3><p><img src="%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/http054.png" alt="状态码类别">  </p><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li>200 OK: 请求已正常处理</li><li>204 No Content: 请求处理成功，但是没有资源可以返回</li><li>206 Partial Content：客户端进行了范围请求，而服务器成功执行了这部分GET请求，返回了部分资源。</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><p>表明浏览器需要执行某些特殊处理以正确处理请求。  </p><ul><li>301 Moved Permanently：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替  </li><li>302 Found：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI  </li><li>303 See Other    ：资源的URI已更新。</li><li>304 Not Modified：资源已找到，但未符合条件请求。</li><li>307 Temporary Redirect：临时重定向。 与302类似。使用GET请求重定向 </li></ul><p><strong>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改称GET，并删除请求报文内的主体，之后请求会自动再次发送。</strong>  </p><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><p>表明客户端是发生错误的原因所在  </p><ul><li>400 Bad Request：请求报文中存在语法错误，服务器无法理解。  </li><li>401 Unauthorized：请求需要有通过HTTP认证的认证信息。</li><li>403：访问被服务器拒绝。如：无访问权限。</li><li>404：没有找到请求的资源。  </li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><p>表明服务器本身发生错误。  </p><ul><li>500 Internal Server Error：服务器内部错误，无法完成请求</li><li>503 Service Unavailable：服务器暂时处于超负荷或者正在进行停机维护，无法处理请求。</li></ul><p><strong>不少返回的状态码可能会和实际情况不一致。</strong>  </p><h2 id="第5章-与HTTP协作的Web服务器"><a href="#第5章-与HTTP协作的Web服务器" class="headerlink" title="第5章 与HTTP协作的Web服务器"></a>第5章 与HTTP协作的Web服务器</h2><h2 id="第6章-HTTP首部"><a href="#第6章-HTTP首部" class="headerlink" title="第6章 HTTP首部"></a>第6章 HTTP首部</h2><h3 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h3><ul><li>请求报文：方法、URI、HTTP版本、HTTP首部字段</li><li>响应报文：HTTP版本、状态码（数字和原因短语）、HTTP首部字段  </li></ul><h4 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h4><p>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> http </tag>
            
            <tag> http状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟DOM</title>
      <link href="/2019/09/02/%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2019/09/02/%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>vdom可以看作是一个使用JavaScript模拟了DOM结构的树形结构，这个树结构包含整个DOM结构的信息如下。<br>左边的DOM结构，不论是标签名称还是标签的属性或标签的子集，都会对应在右边的树结构里。<br><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E8%99%9A%E6%8B%9FDOM.png" alt="虚拟DOM"></p><h2 id="为什么使用虚拟DOM"><a href="#为什么使用虚拟DOM" class="headerlink" title="为什么使用虚拟DOM"></a>为什么使用虚拟DOM</h2><ol><li>使用原生js或者jquery写页面的时候会发现操作DOM是一件非常麻烦的一件事情，往往是DOM标签和js逻辑同时写在js文件里，数据交互时不时还要写很多的input隐藏域，如果没有好的代码规范的话会显得代码非常冗余混乱，耦合性高并且难以维护。</li><li>另外一方面在浏览器里一遍又一遍的渲染DOM是非常非常消耗性能的，常常会出现页面卡死的情况；所以尽量减少对DOM的操作成为了优化前端性能的必要手段，vdom就是将DOM的对比放在了js层，通过对比不同之处来选择新渲染DOM节点，从而提高渲染效率。</li></ol><h2 id="虚拟DOM实现"><a href="#虚拟DOM实现" class="headerlink" title="虚拟DOM实现"></a>虚拟DOM实现</h2><ol><li>通过JavaScript来构建虚拟的DOM树结构，并将其呈现到页面中；</li><li>当数据改变，引起DOM树结构发生改变，从而生成一颗新的虚拟DOM树，将其与之前的DOM对比，将变化部分应用到真实的DOM树中，即页面中。</li></ol><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/createElement.png" alt="createElement"></p><p>通过Element我们可以任意地构建虚拟DOM树了。但是有个问题，虚拟的终归是虚拟的，我们得将其呈现到页面中。</p><h3 id="DFS-深度遍历"><a href="#DFS-深度遍历" class="headerlink" title="DFS(深度遍历)"></a>DFS(深度遍历)</h3><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86.png" alt="深度遍历"></p><h3 id="BFS-广度遍历"><a href="#BFS-广度遍历" class="headerlink" title="BFS(广度遍历)"></a>BFS(广度遍历)</h3><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86.png" alt="广度遍历"></p><p>因为我们得将子节点append到父节点中,选择DFS</p><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E9%87%87%E7%94%A8DFS%E5%AE%9E%E7%8E%B0render.png" alt="采用DFS实现render"></p><p>此时，我们就可以轻松地将虚拟DOM呈现到指定真实DOM中啦。假设，我们将上诉ul虚拟DOM呈现到页面body中，如下：</p><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E5%88%9B%E5%BB%BADOM.png" alt="创建DOM"></p><h3 id="DOM更新"><a href="#DOM更新" class="headerlink" title="DOM更新"></a>DOM更新</h3><p>DOM更新，无外乎四种情况，如下：</p><ol><li>新增节点</li><li>删除节点</li><li>替换节点</li><li>父节点相同，对比子节点</li></ol><p>毫无疑问，遍历DOM树仍然采用DFS遍历。</p><p>因为我们要将变化的节点更新到真实DOM中，所以还得传入真实的DOM根节点，并且真实的DOM节点与虚拟的DOM节点，树形结构一致，故通过标记可以记录节点变化位置，如下：</p><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/dom%E6%9B%B4%E6%96%B0.png" alt="dom更新"></p><p>实现函数如下：</p><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E6%9B%B4%E6%96%B0dom%E5%87%BD%E6%95%B0.png" alt="更新dom函数"></p><p>其中的changed方法，简单实现如下：</p><p><img src="//lyfflied.github.io/2019/09/02/虚拟DOM/%E6%94%B9%E5%8F%98DOm.png" alt="改变DOm"></p><p>文章参考： <a href="https://forgiveforever.github.io/2019/08/31/%E8%99%9A%E6%8B%9FDOM/" target="_blank" rel="noopener">https://forgiveforever.github.io/2019/08/31/%E8%99%9A%E6%8B%9FDOM/</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue_diff算法</title>
      <link href="/2019/09/02/Vue-diff%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/02/Vue-diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-diff算法"><a href="#Vue-diff算法" class="headerlink" title="Vue_diff算法"></a>Vue_diff算法</h1><h2 id="Vue怎么更新节点"><a href="#Vue怎么更新节点" class="headerlink" title="Vue怎么更新节点"></a>Vue怎么更新节点</h2><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</p><p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</p><h2 id="diff的比较方式"><a href="#diff的比较方式" class="headerlink" title="diff的比较方式"></a>diff的比较方式</h2><p>在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</p><pre><code>&lt;div&gt;    &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt;    &lt;span&gt;456&lt;/span&gt;&lt;/div&gt;</code></pre><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：</p><h2 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h2><p>当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。</p><p><img src="//lyfflied.github.io/2019/09/02/Vue-diff算法/diff%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="diff流程图"></p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>来看看patch是怎么打补丁的（代码只保留核心部分）</p><pre><code>function patch (oldVnode, vnode) {    // some code    if (sameVnode(oldVnode, vnode)) {        patchVnode(oldVnode, vnode)    } else {        const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点        let parentEle = api.parentNode(oEl)  // 父元素        createEle(vnode)  // 根据Vnode生成新元素        if (parentEle !== null) {            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素            api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点            oldVnode = null        }    }    // some code     return vnode}</code></pre><p>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点  </p><ol><li>判断两节点是否值得比较，值得比较则执行patchVnode</li></ol><pre><code>function sameVnode (a, b) {  return (    a.key === b.key &amp;&amp;  // key值    a.tag === b.tag &amp;&amp;  // 标签名    a.isComment === b.isComment &amp;&amp;  // 是否为注释节点    // 是否都定义了data，data包含一些具体信息，例如onclick , style    isDef(a.data) === isDef(b.data) &amp;&amp;      sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同  )}</code></pre><ol start="2"><li>不值得比较则用Vnode替换oldVnode</li></ol><p>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</p><p>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…）</p><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。</p><pre><code>patchVnode (oldVnode, vnode) {    const el = vnode.el = oldVnode.el    let i, oldCh = oldVnode.children, ch = vnode.children    if (oldVnode === vnode) return    if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) {        api.setTextContent(el, vnode.text)    }else {        updateEle(el, vnode, oldVnode)        if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) {            updateChildren(el, oldCh, ch)        }else if (ch){            createEle(vnode) //create el&apos;s children dom        }else if (oldCh){            api.removeChildren(el)        }    }}</code></pre><p><strong>这个函数做了以下事情：</strong></p><ul><li>找到对应的真实dom，称为el</li><li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li><li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li><li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li><li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li><li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</li></ul><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><pre><code>updateChildren (parentElm, oldCh, newCh) {    let oldStartIdx = 0, newStartIdx = 0    let oldEndIdx = oldCh.length - 1    let oldStartVnode = oldCh[0]    let oldEndVnode = oldCh[oldEndIdx]    let newEndIdx = newCh.length - 1    let newStartVnode = newCh[0]    let newEndVnode = newCh[newEndIdx]    let oldKeyToIdx    let idxInOld    let elmToMove    let before    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {        if (oldStartVnode == null) {   // 对于vnode.key的比较，会把oldVnode = null            oldStartVnode = oldCh[++oldStartIdx]         }else if (oldEndVnode == null) {            oldEndVnode = oldCh[--oldEndIdx]        }else if (newStartVnode == null) {            newStartVnode = newCh[++newStartIdx]        }else if (newEndVnode == null) {            newEndVnode = newCh[--newEndIdx]        }else if (sameVnode(oldStartVnode, newStartVnode)) {            patchVnode(oldStartVnode, newStartVnode)            oldStartVnode = oldCh[++oldStartIdx]            newStartVnode = newCh[++newStartIdx]        }else if (sameVnode(oldEndVnode, newEndVnode)) {            patchVnode(oldEndVnode, newEndVnode)            oldEndVnode = oldCh[--oldEndIdx]            newEndVnode = newCh[--newEndIdx]        }else if (sameVnode(oldStartVnode, newEndVnode)) {            patchVnode(oldStartVnode, newEndVnode)            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))            oldStartVnode = oldCh[++oldStartIdx]            newEndVnode = newCh[--newEndIdx]        }else if (sameVnode(oldEndVnode, newStartVnode)) {            patchVnode(oldEndVnode, newStartVnode)            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)            oldEndVnode = oldCh[--oldEndIdx]            newStartVnode = newCh[++newStartIdx]        }else {           // 使用key时的比较            if (oldKeyToIdx === undefined) {                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表            }            idxInOld = oldKeyToIdx[newStartVnode.key]            if (!idxInOld) {                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)                newStartVnode = newCh[++newStartIdx]            }            else {                elmToMove = oldCh[idxInOld]                if (elmToMove.sel !== newStartVnode.sel) {                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)                }else {                    patchVnode(elmToMove, newStartVnode)                    oldCh[idxInOld] = null                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)                }                newStartVnode = newCh[++newStartIdx]            }        }    }    if (oldStartIdx &gt; oldEndIdx) {        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)    }else if (newStartIdx &gt; newEndIdx) {        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)    }}</code></pre><p>先说一下这个函数做了什么:</p><ul><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li><li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ul><p><strong>图解updateChildren</strong></p><p><img src="//lyfflied.github.io/2019/09/02/Vue-diff算法/%E5%9B%BE%E8%A7%A3%E6%9B%B4%E6%96%B0%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="图解更新孩子节点"></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2019/09/02/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2019/09/02/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="1-from-amp-amp-set"><a href="#1-from-amp-amp-set" class="headerlink" title="1.from&amp;&amp;set"></a>1.from&amp;&amp;set</h2><pre><code>function ddd1(arr){    let res = Array.from(new Set(arr));    return res;}</code></pre><h2 id="2-filter-amp-amp-indexOf"><a href="#2-filter-amp-amp-indexOf" class="headerlink" title="2.filter &amp;&amp; indexOf"></a>2.filter &amp;&amp; indexOf</h2><pre><code>function ddd2(arr){    let res = arr.filter((item,index,arr)=&gt;{        return arr.indexOf(item) == index;    });    return res;}</code></pre><h2 id="3-forEach-amp-amp-includes"><a href="#3-forEach-amp-amp-includes" class="headerlink" title="3. forEach &amp;&amp; includes"></a>3. forEach &amp;&amp; includes</h2><pre><code>function ddd4(arr){    let res = [];    arr.forEach(item=&gt;{        if(!res.includes(item)) res.push(item);    });    return res;}</code></pre><h2 id="4-filter-amp-amp-map"><a href="#4-filter-amp-amp-map" class="headerlink" title="4. filter &amp;&amp; map"></a>4. filter &amp;&amp; map</h2><pre><code>function ddd4(arr){    const tem = new Map();    let res = arr.filter(itme=&gt;{        return !tem.has(item) &amp;&amp; tem.set(item,1);    });    return res;}</code></pre><h2 id="5-引用类型数组去重"><a href="#5-引用类型数组去重" class="headerlink" title="5. 引用类型数组去重"></a>5. 引用类型数组去重</h2><pre><code>function ddd5(arr){    let hash = {};    arr = arr.reduce((itme,next)=&gt;{        hash[next.name]? &apos;&apos; : hash[next.name] = true &amp;&amp; item.push(next);        return item;    },[]);    return arr;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组扁平化</title>
      <link href="/2019/09/02/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
      <url>/2019/09/02/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><pre><code>function flatten1(arr){    let result = [];    for(var i =0;i&lt;arr.length;i++){        if(Array.isArray(arr[i])){            result = result.concat(flatten1(arr[i]));        }else{            result.push(arr[i]);        }    }    return result;}</code></pre><h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2. toString"></a>2. toString</h2><pre><code>function flatten2(arr){   let arr = arr.join(&apos;,&apos;).split(&apos;,&apos;);   arr = arr.map(itme=&gt;+item); //将被转成字符串的数字转换回去；   return arr;}</code></pre><h2 id="3-reduce"><a href="#3-reduce" class="headerlink" title="3. reduce()"></a>3. reduce()</h2><pre><code>function flatten3(arr){    return arr.reduce((prev,next)=&gt;{        return prev.concat(Array.isArray(next)? flatten3(next) : next);    },[])}</code></pre><h2 id="4-…扩展运算符"><a href="#4-…扩展运算符" class="headerlink" title="4. …扩展运算符"></a>4. …扩展运算符</h2><pre><code>function ddd4(arr){    while(arr.some(item=&gt;{Array.isArray(itme)})){        arr = [].concat(...arr);    }    return arr;}</code></pre><h2 id="5-arr-flat"><a href="#5-arr-flat" class="headerlink" title="5. arr.flat()"></a>5. arr.flat()</h2><pre><code>//arr.flat()   会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 //Infinity 无穷大， -Infinity无穷小function flatten5(arr){    return  arr.flat(Infinity);}</code></pre><h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a>6. JSON</h2><pre><code>function flatten6(arr){    let str = JSON.stringify(arr);    let str1 = str.replace(/\[|\]/g,&apos;&apos;);    let arr1 = str1.split(&apos;,&apos;);    return arr1.map(item=&gt;+item);//将被转成字符串的数字转换回去；}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调炼狱_树形导航</title>
      <link href="/2019/09/01/%E5%9B%9E%E8%B0%83%E7%82%BC%E7%8B%B1-%E6%A0%91%E5%BD%A2%E5%AF%BC%E8%88%AA/"/>
      <url>/2019/09/01/%E5%9B%9E%E8%B0%83%E7%82%BC%E7%8B%B1-%E6%A0%91%E5%BD%A2%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="回调炼狱-树形导航"><a href="#回调炼狱-树形导航" class="headerlink" title="回调炼狱_树形导航"></a>回调炼狱_树形导航</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在做项目的时候曾被要求写过一个树形的导航栏。当时也没多想，直接搞了一串的嵌套后台请求。<br>根据根节点ID去后台查询子节点信息——&gt;<br>根据子节点ID去后台查询孙子节点ID——&gt;<br>。。。一系列嵌套查询  </p><p>一度导致页面加载速度缓慢。<br>后来被指出，你这简直是回调炼狱。<br>于是去了解了解了回调炼狱。</p><h1 id="回调炼狱"><a href="#回调炼狱" class="headerlink" title="回调炼狱"></a>回调炼狱</h1><h2 id="什么是回调炼狱"><a href="#什么是回调炼狱" class="headerlink" title="什么是回调炼狱"></a>什么是回调炼狱</h2><p>说起回调地狱 首先想到的是异步，在js中我们经常会大量使用异步回调，例如使用ajax请求<br>我们来看下面这段代码：</p><pre><code>function getNode1(id){    function getNode2(node1Id){        function getNode3(node2Id){            function getNode4(node3Id){                function getNode5(node4Id){                }            }        }    }}</code></pre><p>我们发现上面代码大量使用了回调函数（将一个函数的结果作为参数传递给另个函数）并且有许多 }结尾的符号，使得代码看起来很混乱。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="避免如此调用"><a href="#避免如此调用" class="headerlink" title="避免如此调用"></a>避免如此调用</h2><p>后来直接在后台把数据查询完之后，返回给了前台。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><pre><code>//获取第一个节点var getNode1 = new Promise((resolve,reject)=&gt;{    $.ajax({        type:&quot;get&quot;,        url:&quot;****&quot;,        success:function(data){            if(data.Status == &quot;1&quot;){            resolve(data.result);        }else{            reject(data.err);        }    });})//获取第二个节点var getNode2 = new Promise((resolve,reject)=&gt;{    $.ajax({        type:&quot;get&quot;,        url:&quot;****&quot;,        success:function(data){            if(data.Status == &quot;1&quot;){                resolve(data.result);            }else{                reject(data.err);            }        }    });})//Promise的then(),catch()；getNode1.then(function(dataId){    return getNode2;}).catch(err=&gt;{//处理失败时。})//Promise的all()方法，等数组中的所有promise对象都完成执行Promise.all([getNode1,getNode2]).then(function([ResultJson1,ResultJson2]){//这里写等这两个ajax都成功返回数据才执行的业务逻辑})</code></pre>]]></content>
      
      
      <categories>
          
          <category> 遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目中遇到的问题 </tag>
            
            <tag> 回调炼狱 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Safari无痕模式下，storage被禁用问题</title>
      <link href="/2019/08/30/Safari%E6%97%A0%E7%97%95%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8Cstorage%E8%A2%AB%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/30/Safari%E6%97%A0%E7%97%95%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8Cstorage%E8%A2%AB%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Safari无痕模式下，storage被禁用"><a href="#Safari无痕模式下，storage被禁用" class="headerlink" title="Safari无痕模式下，storage被禁用"></a>Safari无痕模式下，storage被禁用</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Safari开启无痕模式后，localStorage和sessionStorage为空，对其进行set操作也会报错，也就是说这种情况下，storage是被禁止使用了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>对storage进行一层封装，遇到这种开启无痕模式的情况，会定义一个window的全局变量，把之前准备存放到storage的内容改为存到这个全局变量中。</li><li>无痕模式下localStorage和sessionStorage对象本身依然是存在的，只是调用setItem方法是会报错。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>try {     sessionStorage.setItem(&apos;private_test&apos;, 1);   } catch (e) {     //无痕模式   }</code></pre><ul><li>另外定义一个NameStorage对象，在原生storage失效时使用</li></ul><pre><code>// 隐私模式下面，把临时值存到window.name中去  function NameStorage(type) {    this.store = NameStorage[type];  }  Object.assign(NameStorage.prototype, {    getItem: function(key) {      return this.store[key];    },    setItem: function(key, value) {      this.store[key] = value;      this._saveNameValue();    },    removeItem: function(key) {      delete this.store[key];      this._saveNameValue();    },    clear: function() {      this.store = {};      this._saveNameValue();    },    _saveNameValue: function() {      var ret = {        session: NameStorage.session,        local: NameStorage.local      }      window.name = JSON.stringify(ret);    }  });</code></pre><ul><li>上面会把所有的local和session数据存储到window.name上去，然后在每个页面启动时，调用一下keepName方法，把window.name的数据拿下来放到NameStorage上面。这时候，只需要调用new NameStorage(‘local’)来代替localStorage进行操作就行了</li></ul><pre><code>function keepName () {    if (keepName.done) {      return;    }    var ret;    if (window.name) {      try {        ret = JSON.parse(window.name);      } catch (e) {        ret = {};      }    }    if (!_.isPlainObject(ret)) {      ret = {};    }    if (!ret.session) {      ret.session = {};    }    if (!ret.local) {      ret.local = {};    }    NameStorage.session = ret.session;    NameStorage.local = ret.local;    keepName.done = true;  }</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>无痕模式下，localStorage和sessionStorage的报错信息是：QuotaExceededError，code为22，这个其实是storage存储空间用完了报的错，就比如当前浏览器storage内存为5mb，你已经存储了5mb的数据后，再进行setItem操作就会报这个错误。</li><li>所以我猜想无痕模式下，浏览器是把storage的内存先清空，然后再设置最大值为0，这样调用setItem就直接报错了。</li><li>另外无痕模式下cookie是可以使用的，大概因为cookie是跟服务器有关，而storage是属于浏览器的特性吧。</li><li>最后还有一种情况，就是无痕模式下打开了某个页面，然后把浏览器关闭再打开，这个时候会打开访问的页面，但是window.name已经丢失了，所以就拿不到以前存储的数据了。这种情况只能页面做容错处理了。</li></ul><p>参考原文链接： <a href="https://www.jianshu.com/p/ae5f1e3ed84d" target="_blank" rel="noopener">https://www.jianshu.com/p/ae5f1e3ed84d</a></p>]]></content>
      
      
      <categories>
          
          <category> 遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目中遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符匹配算法</title>
      <link href="/2019/08/28/KMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/28/KMP%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="匹配值表"><a href="#匹配值表" class="headerlink" title="匹配值表"></a>匹配值表</h2><p>对于 KMP 来说，“匹配值表”是很关键的。</p><p>前缀：从 0 位，依次截取 1 到(len - 1)长度字符串的集合<br>后缀：从 len - 1 位反序，依次截取 1 到(len - 1)长度字符串的集合<br>匹配值:是指前缀和后缀集合，最长共有元素的长度，即交集中最长元素的长度</p><p><strong>例子</strong> ：我们需要查找的字符串是 “ABABABCA”。</p><p><img src="//lyfflied.github.io/2019/08/28/KMP字符匹配算法/20190828_1.png" alt="匹配值表" title="匹配值表"></p><p>char: | A | B | A | B | A | B | C | A |<br>index:| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |<br>value:| 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>移动位数 = 已匹配字符长度 - 对应位的匹配值</p><pre><code>  //  计算部分匹配表  function kmpGetStrPartMatchValue(str) {var prefix = [];var suffix = [];var partMatch = [];for(var i=0,j=str.length;i&lt;j;i++){    var newStr = str.substring(0,i+1);    if(newStr.length == 1){        partMatch[i] = 0;    } else {        for(var k=0;k&lt;i;k++){            prefix[k] = newStr.slice(0,k+1);            suffix[k] = newStr.slice(-k-1);            if(prefix[k] == suffix[k]){                partMatch[i] = prefix[k].length;            }        }        if(!partMatch[i]){            partMatch[i] = 0;        }    }}prefix.length = 0;suffix.length = 0;return partMatch;}//KMP回退算法function KMP(sourceStr,targetStr){    var partMatchValue = kmpGetStrPartMatchValue(targetStr);    var result = false;    for(var i=0,j=sourceStr.length;i&lt;j;i++){        for(var m=0,n=targetStr.length;m&lt;n;m++){            if(targetStr.charAt(m) == sourceStr.charAt(i)){                if(m == targetStr.length-1){                    result = true;                    break;                } else {                    i++;                }            } else {                if(m&gt;0 &amp;&amp; partMatchValue[m-1] &gt; 0){                    m = partMatchValue[m-1]-1;                } else {                    break;                }            }        }        if(result){            break;        }    }    return result;}var s = &quot;BBC ABCDAB ABCDABCDABDE&quot;;var t = &quot;ABCDABD&quot;;console.log(KMP(s,t));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用velocity解决poi-tl数据缺失不渲染的问题</title>
      <link href="/2019/08/27/%E5%88%A9%E7%94%A8velocity%E8%A7%A3%E5%86%B3poi-tl%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8D%E6%B8%B2%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/27/%E5%88%A9%E7%94%A8velocity%E8%A7%A3%E5%86%B3poi-tl%E6%95%B0%E6%8D%AE%E7%BC%BA%E5%A4%B1%E4%B8%8D%E6%B8%B2%E6%9F%93%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目中遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-show和v-if</title>
      <link href="/2019/08/27/v-show%E5%92%8Cv-if/"/>
      <url>/2019/08/27/v-show%E5%92%8Cv-if/</url>
      
        <content type="html"><![CDATA[<h1 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在做项目的时候遇到一个问题，选项卡中的一个板块可以让用户点击选择显示/隐藏（默认隐藏）。当切换选项卡时，隐藏模块中数据应该根据不同的选项卡去渲染不同的数据。当时我们采用的是v-show，出现了一个问题：当点击不同的选项卡时，隐藏模块中的数据没有改变。<br>经过查阅资料了解到，这里使用v-for可以解决v-show的问题。(v-if控制下，元素会销毁和重建)<br>于是整理了一下v-if和v-show的异同。</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>功能控制元素的显隐性</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><strong>v-if</strong> ：动态地向DOM树内添加或者删除DOM元素；元素会销毁和重建。<br><strong>v-show</strong> ：是通过设置DOM元素的display样式属性控制显隐； </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果需要非常频繁地切换，则使用v-show较好；<br>如果在运行时条件不太可能改变，则使用 v-if 较好；<br>据用户不同的权限,对功能进行显示/隐藏时用v-if比较好，因为v-show：style=”display: none; 可以被修改。<br>v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> 遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目中遇到的问题 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法——台阶问题</title>
      <link href="/2019/08/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划算法——台阶问题"><a href="#动态规划算法——台阶问题" class="headerlink" title="动态规划算法——台阶问题"></a>动态规划算法——台阶问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p><p>比如，每次走1级台阶，一共走10步，这是其中一种走法。我们可以简写成 1,1,1,1,1,1,1,1,1,1。<br>再比如，每次走2级台阶，一共走5步，这是另一种走法。我们可以简写成 2,2,2,2,2。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>动态规划中三个重要的概念：最优子结构、边界、状态转移公式</p><p> F(1) = 1;     边界</p><p> F(2) = 2;     边界</p><p>F(n) = F(n-1)+F(n-2)（n&gt;=3）    状态转移方程（核心）</p><p>F(8)、F(9)是F(10)的最优子结构</p><h3 id="方法一：递归求解"><a href="#方法一：递归求解" class="headerlink" title="方法一：递归求解"></a>方法一：递归求解</h3><p>时间复杂度：o(2^n)</p><pre><code>function getClimbingWaysByRecursion(n){            if(n&lt;1) return 0;            if(n==1) return 1;            if(n==2) return 2;            return getClimbingWaysByRecursion(n-1)+getClimbingWaysByRecursion(n-2);}</code></pre><h3 id="方法二：备忘录算法"><a href="#方法二：备忘录算法" class="headerlink" title="方法二：备忘录算法"></a>方法二：备忘录算法</h3><p>对方法一的优化，将重复计算的结果用map存起来。<br>时间复杂度和空间复杂度都是O(N)</p><pre><code>let arr =new Map();function getClimbingWaysByMemorandum(n){    if(n&lt;1) return 0;    if(n==1) return 1;    if(n==2) return 2;    if(arr.has(n)){        return arr.get(n);    }else{        let value = getClimbingWaysByMemorandum(n-1)+getClimbingWaysByMemorandum(n-2);        arr.set(n,value);        return value;    }}</code></pre><h3 id="方法三：-动态规划解法"><a href="#方法三：-动态规划解法" class="headerlink" title="方法三： 动态规划解法"></a>方法三： 动态规划解法</h3><p>每次的结果都依赖于前两次的结果，所以，自底向上求解，F(n)只依赖于F(n-1)和F(n-2)<br>时间复杂度：O(N)<br>空间复杂度：O(1)  </p><pre><code>function getClimbingWaysByDynamicProgramming(n){    if(n&lt;1) return 0;    if(n==1) return 1;    if(n==2) return 2;     let a = 1;    let b = 2;    let temp = 0;    for(let i = 3;i&lt;=n;i++){            temp = a+b;            a = b;            b = temp;        }    return temp;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局</title>
      <link href="/2019/08/27/CSS%E5%B8%83%E5%B1%80/"/>
      <url>/2019/08/27/CSS%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex布局-弹性布局"><a href="#Flex布局-弹性布局" class="headerlink" title="Flex布局(弹性布局)"></a>Flex布局(弹性布局)</h1><h2 id="一、Flex布局是什么"><a href="#一、Flex布局是什么" class="headerlink" title="一、Flex布局是什么"></a>一、Flex布局是什么</h2><p>任何一个容器都可以指定为Flex布局</p><pre><code>.box{    display:flex;}</code></pre><p>行内元素也可以使用Flex布局</p><pre><code>.box{    display:inline-flex;}</code></pre><p>Webkit内核的浏览器，必须加上-webkit前缀</p><pre><code>.box{    display:-webkit-flex;/*Safari*/    display:flex;}</code></pre><p><strong>注意</strong>：设置为flex布局后，子元素的float、clear、vertical-align属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。  </p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>有六个属性：<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content  </p><h3 id="3-1-flex-direction"><a href="#3-1-flex-direction" class="headerlink" title="3.1 flex-direction"></a>3.1 flex-direction</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><pre><code>.box {  flex-direction: row(默认) | row-reverse | column | column-reverse;}/*row(默认)：主轴为水平方向，起点在左端。row-reverse: 主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴在垂直方向，起点在下沿。*/</code></pre><h3 id="3-2-flex-wrap"><a href="#3-2-flex-wrap" class="headerlink" title="3.2 flex-wrap"></a>3.2 flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><pre><code>.box{    flex-wrap: nowrap(默认) | wrap | wrap-reverse;}/*nowrap（默认）：不换行；wrap：换行，第一行在上方wrap-reverse：换行，第一行在下方*/</code></pre><h3 id="3-3flex-flow（排列）"><a href="#3-3flex-flow（排列）" class="headerlink" title="3.3flex-flow（排列）"></a>3.3flex-flow（排列）</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><pre><code>.box {  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;}</code></pre><h3 id="3-4justify-content-主轴对齐方式"><a href="#3-4justify-content-主轴对齐方式" class="headerlink" title="3.4justify-content(主轴对齐方式)"></a>3.4justify-content(主轴对齐方式)</h3><p>justify-content属性定义了项目在主轴上的对齐方式。  </p><pre><code>.box {    justify-content: flex-start | flex-end | center | space-between | space-around;}/*flex-start（默认值）：左对齐；flex-end：右对齐center：居中；space-between:两端对齐，项目之前间隔相等；space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。（两边也不靠边）*/</code></pre><h3 id="3-5align-items（交叉轴对齐）"><a href="#3-5align-items（交叉轴对齐）" class="headerlink" title="3.5align-items（交叉轴对齐）"></a>3.5align-items（交叉轴对齐）</h3><pre><code>.box {  align-items: flex-start | flex-end | center | baseline | stretch;}/*stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。*/</code></pre><h3 id="3-6align-content"><a href="#3-6align-content" class="headerlink" title="3.6align-content"></a>3.6align-content</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><pre><code>.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}/*stretch(默认值)：轴线占满整个交叉轴；flex-start：与交叉轴的起点对齐flex-end：与交叉轴的终点对齐center：与交叉轴的中点对齐；space-between：与交叉轴两端对齐，轴线之间的间隔平均分布；space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍；*/</code></pre><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><p>order<br>flex-grow<br>flex-shrink<br>flex-basis<br>flex<br>align-self  </p><h3 id="4-1-order"><a href="#4-1-order" class="headerlink" title="4.1 order"></a>4.1 order</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。  </p><pre><code>.item {  order: &lt;integer&gt;;}</code></pre><h3 id="4-2-flex-grow"><a href="#4-2-flex-grow" class="headerlink" title="4.2 flex-grow"></a>4.2 flex-grow</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>.item {  flex-grow: &lt;number&gt;; /* default 0 */}</code></pre><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink"><a href="#4-3-flex-shrink" class="headerlink" title="4.3 flex-shrink"></a>4.3 flex-shrink</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。  </p><pre><code>.item {  flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis"><a href="#4-4-flex-basis" class="headerlink" title="4.4 flex-basis"></a>4.4 flex-basis</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>.item {  flex-basis: &lt;length&gt; | auto; /* default auto */}</code></pre><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex（放大，缩小，所占空间）"><a href="#4-5-flex（放大，缩小，所占空间）" class="headerlink" title="4.5 flex（放大，缩小，所占空间）"></a>4.5 flex（放大，缩小，所占空间）</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre><code>.item {  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]}</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self"><a href="#4-6-align-self" class="headerlink" title="4.6 align-self"></a>4.6 align-self</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex实现五种常用布局</title>
      <link href="/2019/08/27/Flex%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/"/>
      <url>/2019/08/27/Flex%E5%AE%9E%E7%8E%B0%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex实现五大常用布局"><a href="#Flex实现五大常用布局" class="headerlink" title="Flex实现五大常用布局"></a>Flex实现五大常用布局</h1><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;div1&quot;&gt;    &lt;header&gt;HEADER&lt;/header&gt;    &lt;article&gt;CONTENT&lt;/article&gt;    &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;    &lt;header&gt;header&lt;/header&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;aside&gt;ASIDE&lt;/aside&gt;        &lt;article&gt;article&lt;/article&gt;    &lt;/div&gt;    &lt;footer&gt;footer&lt;/footer&gt;&lt;/div&gt;&lt;div class=&quot;div3&quot;&gt;&lt;aside&gt;aside&lt;/aside&gt;&lt;div class=&quot;content&quot;&gt;&lt;header&gt;header&lt;/header&gt;&lt;article&gt;article&lt;/article&gt;&lt;footer&gt;footer&lt;/footer&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;!-- &lt;div class=&quot;div4&quot;&gt;            &lt;header&gt;HEADER&lt;/header&gt;            &lt;article&gt;CONTENT&lt;/article&gt;            &lt;footer&gt;FOOTER&lt;/footer&gt;    &lt;/div&gt; --&gt;    &lt;div class=&quot;div5&quot;&gt;        &lt;aside&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;            &lt;p&gt;item&lt;/p&gt;        &lt;/aside&gt;        &lt;div class=&quot;content&quot;&gt;            &lt;header&gt;header&lt;/header&gt;            &lt;article&gt;&lt;div&gt;content&lt;/div&gt;&lt;/article&gt;            &lt;footer&gt;footer&lt;/footer&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;style&gt;/* 1.vw：1vw等于视口宽度的1%。2.vh：1vh等于视口高度的1%。3.vmin：选取vw和vh中最小的那个。4.vmax：选取vw和vh中最大的那个。 */body{    min-height: 100vh;        display: flex;    flex-direction: column;}/* 1.经典的上-中-下布局。 */.div1&gt;article{    background-color: aqua;    flex:auto;}.div1&gt;header,.div1 footer{    background-color: rgb(46, 223, 140)}.div1{    min-height: 20vh;    display: flex;    flex-direction: column;}/* 2.在上-中-下布局的基础上，加了左侧定宽 sidebar。 */.div2{    min-height: 20vh;    display: flex;    flex-direction: column;}.div2 .content{    flex:1 0 auto;    display:flex;    background-color: aqua;} .div2 .content article{    flex:1 0 auto;    background-color: darkgrey;}.div2 header,.div2 footer{    background-color: bisque;}/* 3.左边是定宽 sidebar，右边是上-中-下布局。 */.div3{    display:flex;    flex-flow: row;    min-height:20vh;}.div3 aside{    background-color: aqua;}.div3 .content{    display: flex;    flex: 1 0 auto;    flex-flow: column;}.div3 article{    flex:1 0 auto;    background-color: antiquewhite;}.div3 header,.div3 footer{    background-color: aquamarine;}/* 4. 还是上-中-下布局，区别是 header 固定在顶部，不会随着页面滚动。 *//* body {  min-height: 100vh;  display: flex;  flex-direction: column;  padding-top: 60px;}header {  height: 60px;  position: fixed;  top: 0;  left: 0;  right: 0;  padding: 0;}article {  flex: auto;  height: 1000px;} *//* 5.左侧 sidebar 固定在左侧且与视窗同高，当内容超出视窗高度时，在 sidebar 内部出现滚动条。左右两侧滚动条互相独立。 */.div5{    min-height:20vh;    display:flex;    flex-flow:row;}/* overflow-y: visible|hidden|scroll|auto|no-display|no-content;visible    不裁剪内容，可能会显示在内容框之外。hidden    裁剪内容 - 不提供滚动机制。scroll    裁剪内容 - 提供滚动机制。auto    如果溢出框，则应该提供滚动机制。no-display    如果内容不适合内容框，则删除整个框。no-content    如果内容不适合内容框，则隐藏整个内容。 */.div5 aside{    background-color: aqua;    flex: 0 1 10%;    overflow-y: auto;    max-height:20vh;}.div5 .content{    display:flex;    flex:auto;    flex-flow: column;}.div5 header,.div5 footer{    background-color: blanchedalmond;}/* 设置垂直水平居中 */.div5 article{    flex: auto;    background-color: aliceblue;    display: flex;    align-items: center;    justify-content: center;}&lt;/style&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax以及跨域</title>
      <link href="/2019/08/25/Ajax%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/08/25/Ajax%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h2><pre><code>function ajax(url){        var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : ActiveXObject(&quot;microsoft.XMLHttp&quot;)        xhr.open(&quot;get&quot;,url,true);        xhr.send();        xhr.onreadystatechange = () =&gt;{            if(xhr.readyState == 4){                if(xhr.status == 200){                    var data = xhr.responseText;                    return data;                }            }        }        }</code></pre><h3 id="原生GET请求"><a href="#原生GET请求" class="headerlink" title="原生GET请求"></a>原生GET请求</h3><pre><code>var  xmlhttp = null; if (window.XMLHttpRequest) {// code for Firefox, Opera, IE7, etc.     xmlhttp = new XMLHttpRequest(); } else if (window.ActiveXObject) {// code for IE6, IE5     xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //编写回调函数 xmlhttp.onreadystatechange = function() {     if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) {         alert(xmlhttp.responseText)     } } //open设置请求方式和请求路径 xmlhttp.open(&quot;get&quot;, &quot;/Ajax/ajax2?username=张三&quot;);//一个servlet，后面还可以写是否同步 //send 发送 xmlhttp.send();</code></pre><h3 id="原生POST请求"><a href="#原生POST请求" class="headerlink" title="原生POST请求"></a>原生POST请求</h3><pre><code>var xmlhttp = null;if (window.XMLHttpRequest) {// code for Firefox, Opera, IE7, etc.    xmlhttp = new XMLHttpRequest();} else if (window.ActiveXObject) {// code for IE6, IE5    xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);}//编写回调函数xmlhttp.onreadystatechange = function() {    if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) {        alert(xmlhttp.responseText)    }}//open设置请求方式和请求路径xmlhttp.open(&quot;post&quot;, &quot;/Ajax/ajax2&quot;);//一个servlet，后面还可以写是否同步//设置请求头xmlhttp.setRequestHeader(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;)//send 发送xmlhttp.send(&quot;username=张三&quot;);</code></pre><h2 id="Jquery版Ajax"><a href="#Jquery版Ajax" class="headerlink" title="Jquery版Ajax"></a>Jquery版Ajax</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><pre><code>$.ajax({//请求方式    type:&apos;GET&apos;,    //发送请求的地址以及传输的数据    url:&apos;fzz.php?number&apos;+=xxx,    //服务器返回的数据类型    dataType:&apos;json&apos;,    success:function(data){        //请求成功函数内容    },    error:function(jqXHR){        //请求失败函数内容    }});</code></pre><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><pre><code>$.ajax({    //请求方式    type:&apos;POST&apos;,    //发送请求的地址    url:&apos;fzz.php&apos;,    //服务器返回的数据类型    dataType:&apos;json&apos;,    //发送到服务器的数据，对象必须为key/value的格式，jquery会自动转换为字符串格式    data:{name:xxx,age:xxx},    success:function(data){        //请求成功函数内容    },    error:function(jqXHR){        //请求失败函数内容    }});</code></pre><h3 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h3><pre><code>$.get(&apos;fzz.php&apos;,{    //发送至服务器的数据，格式为key/value    number:xxx  },function(data){    //请求成功时的callback},&apos;json&apos;);//json为返回内容的格式</code></pre><h3 id="post"><a href="#post" class="headerlink" title="$.post()"></a>$.post()</h3><pre><code>$.post(&apos;fzz.php&apos;,{    //发送至服务器的数据，格式为key/value    number:xxx  },function(data){    //请求成功时的callback},&apos;json&apos;);//json为返回内容的格式</code></pre><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p>能载入远程HTML代码并插入DOM中</p><pre><code>//data为发送的key/value数据，可选//callback为请求完成的回调，可选无论请求成功或失败都会调用$(‘xxx’).load(‘fzz.html’,data,callback);</code></pre><h3 id="serialize-方法"><a href="#serialize-方法" class="headerlink" title="serialize()方法"></a>serialize()方法</h3><p>serialize()作用于一个jQuery对象，能够将DOM元素内容序列化为字符串,用于Ajax请求.</p><pre><code>$(‘#form1’).serialize();</code></pre><h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>同源策略<br>协议、域名、端口号  </p><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><ul><li>jsonp解决跨域</li><li>CORS跨域资源共享</li><li>document.domain</li></ul><h4 id="jsonp解决跨域"><a href="#jsonp解决跨域" class="headerlink" title="jsonp解决跨域"></a>jsonp解决跨域</h4><p><strong>原理</strong>：动态创建一个script标签。利用script标签的src属性不受同源策略限制。因为所有的src属性和href属性都不受同源策略限制。可以请求第三方服务器数据内容。<br>步骤</p><ul><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。</li><li>通过定义函数名去接收后台返回数据</li></ul><pre><code>//去创建一个script标签 var script = document.createElement(&quot;script&quot;); //script的src属性设置接口地址 并带一个callback回调函数名称 script.src=&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;;//插入到页面 document.head.appendChild(script); //通过定义函数名去接收后台返回数据 function jsonpCallback(data){ //注意 jsonp返回的数据是json对象可以直接使用 //ajax 取得数据是json字符串需要转换成json对象才可以使用。 }</code></pre><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><p><strong>原理</strong>：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求<br><strong>限制</strong>：浏览器需要支持HTML5，可以支持POST，PUT等方法兼容ie9以上<br>需要后台设置</p><pre><code>Access-Control-Allow-Origin: * //允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com //只允许所有域名访问</code></pre><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p><strong>原理</strong>：相同主域名不同子域名下的页面，可以设置document.domain让它们同域  </p><p><strong>限制</strong>：同域document提供的是页面间的互操作，需要载入iframe页面</p><pre><code>// URL http://a.com/foovar ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://b.a.com/bar&apos;; ifr.onload = function(){    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);};ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);</code></pre><p><strong>参考文章</strong>：<a href="https://forgiveforever.github.io/2019/08/26/Ajax/" target="_blank" rel="noopener">https://forgiveforever.github.io/2019/08/26/Ajax/</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue_MVVM</title>
      <link href="/2019/08/25/Vue-MVVM/"/>
      <url>/2019/08/25/Vue-MVVM/</url>
      
        <content type="html"><![CDATA[<h1 id="对于MVVM的理解"><a href="#对于MVVM的理解" class="headerlink" title="对于MVVM的理解"></a>对于MVVM的理解</h1><p>MVVM 是 Model-View-ViewModel 的缩写。<br>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。  </p><p>Controller不再像MVC那样直接持有Model了，Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“如何解析Model”给封装起来了</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2019/08/25/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/08/25/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><h3 id="beforeCreate（创建前）"><a href="#beforeCreate（创建前）" class="headerlink" title="beforeCreate（创建前）"></a>beforeCreate（创建前）</h3><p>在数据观测和初始化事件还未开始</p><h3 id="created（创建后）"><a href="#created（创建后）" class="headerlink" title="created（创建后）"></a>created（创建后）</h3><p>完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</p><h3 id="beforeMount（载入前）"><a href="#beforeMount（载入前）" class="headerlink" title="beforeMount（载入前）"></a>beforeMount（载入前）</h3><p>在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</p><h3 id="mounted（载入后）"><a href="#mounted（载入后）" class="headerlink" title="mounted（载入后）"></a>mounted（载入后）</h3><p>在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p><h3 id="beforeUpdate（更新前）"><a href="#beforeUpdate（更新前）" class="headerlink" title="beforeUpdate（更新前）"></a>beforeUpdate（更新前）</h3><p>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p><h3 id="updated（更新后）"><a href="#updated（更新后）" class="headerlink" title="updated（更新后）"></a>updated（更新后）</h3><p>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p><h3 id="beforeDestroy（销毁前）"><a href="#beforeDestroy（销毁前）" class="headerlink" title="beforeDestroy（销毁前）"></a>beforeDestroy（销毁前）</h3><p>在实例销毁之前调用。实例仍然完全可用。</p><h3 id="destroyed（销毁后）"><a href="#destroyed（销毁后）" class="headerlink" title="destroyed（销毁后）"></a>destroyed（销毁后）</h3><p>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p><h2 id="什么是vue生命周期？"><a href="#什么是vue生命周期？" class="headerlink" title="什么是vue生命周期？"></a>什么是vue生命周期？</h2><p>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。  </p><h2 id="vue生命周期的作用是什么？"><a href="#vue生命周期的作用是什么？" class="headerlink" title="vue生命周期的作用是什么？"></a>vue生命周期的作用是什么？</h2><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。  </p><h2 id="vue生命周期总共有几个阶段"><a href="#vue生命周期总共有几个阶段" class="headerlink" title="vue生命周期总共有几个阶段"></a>vue生命周期总共有几个阶段</h2><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。 </p><h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><p>会触发 下面这几个beforeCreate, created, beforeMount, mounted 。 </p><h2 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h2><p>DOM 渲染在 mounted 中就已经完成了。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>ISO制定了国际标准OSI（开放式系统互联网通信参考模型），将复杂的协议分为7层。TCP/IP将通信的过程抽象为4层，被视为简化的OSI模型，由IETF负责维护。<br>应用层（应用层）：SMTP、FTP、HTTP<br>表示层（应用层）<br>会话层（应用层）<br>传输层（传输层）：TCP、UDP<br>网络层（互联网层）：IP<br>数据链路层（网络接口层）：以太网<br>物理层（网络接口层）  </p><p>发送的数据会在分层模型内传递，每到一层，就会附加该层的包首部–包含该层的协议的相关信息，包括MAC地址、IP地址和端口号。  </p><h2 id="HTTP-HTTP1-1"><a href="#HTTP-HTTP1-1" class="headerlink" title="HTTP(HTTP1.1)"></a>HTTP(HTTP1.1)</h2><p>HTTP即超文本传输协议，是一种获取网络资源（如图像、HTML、文档）的应用层协议，由请求和响应构成。  </p><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI：统一资源标识符，由URL（统一资源定位符）和URN（统一资源名称，URI过去的名字）组成。URL：包括绝对和相对两种表示方式，相对URL请求的资源必须在同一台服务器中。  </p><ol><li>协议方案scheme（HTTP/FTP）</li><li>登录信息user/password</li><li>主机host（用域名或IP地址表示）</li><li>端口port</li><li>路径path</li><li>查询字符串query</li><li>片段frag</li></ol><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议有三个特征：持久连接、管道化以及无状态。  </p><ol><li>持久连接：通信两端的任意一端没有明确提出断开，就保持连接状态。</li><li>管道化：将队列顺序迁移到服务器，可以同时发送多个请求。</li><li>状态管理：HTTP是无状态协议，请求和响应一一对应，每个请求都是独立的。为了能够管理状态，引入了Cookie技术。</li></ol><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文就是HTTP协议通信的内容，是一种简单的格式化数据块，由带语义的纯文本组成。  </p><ol><li>请求报文：请求方法、请求URL、HTTP协议版本、可选的请求首部和内容</li><li>响应报文：HTTP协议版本、状态码、原因短语、可选的响应首部和内容</li></ol><ul><li>请求方法：GET获取数据、POST提交数据、PUT上传文件、DELETE删除文件、HEAD获取除了内容以外的资源信息。</li><li>状态码：1xx信息、2xx成功、3xx重定向、4xx客户端错误、5xx服务器错误。</li></ul><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><ol><li>通用首部：既可以存在于请求中，也可以存在于响应中。</li><li>请求首部：只存在于请求报文中，提供客户端的信息及对服务器的要求。accept首部表示可接受的MIME类型，MIME类型就是媒体类型，accept首部能同时制定多种媒体类型并分别增加权重。 </li><li>响应首部：只存在于响应报文中，提供服务器的信息及对客户端的要求。</li><li>实体首部：请求和响应都可能包含实体首部，提供大量的实体信息。</li><li>扩展首部  </li></ol><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存的处理过程：(三步)<br>（1）在缓存中搜索指定资源的副本，如果命中就执行第二步。<br>（2）对资源副本进行新鲜度检测，如果不新鲜就执行第三步。<br>（3）与服务器进行再验证。验证通过就更新资源副本的新鲜度，再返回这个资源副本；不通过就从服务器返回资源，再将最新资源的副本放入缓存中。  </p><ul><li>新鲜度检测：通用首部Cache-Control和实体首部Expires会为每一个资源附加一个过期日期。实体首部会指定具体地过期日期，但由于服务器的时钟不同步会导致误差；通用首部能制定资源处于新鲜状态的秒数。Cache-Control中no-cache可以将资源缓存，no-store禁止资源被缓存。</li><li>日期比对法进行再验证：在响应报文中附加实体首部Last-Modified指明资源最后修改日期。验证时，在请求报文中附加If-Modified-Since首部，携带最后修改日期，与服务器上的日期进行对比。依赖服务器上日期准确。</li><li>实体标记法进行再验证：服务器会为每个资源生成唯一的字符串形式的标记，保存在实体首部ETag中。验证时，在请求报文中附加If-None-Match首部，只有当携带的标记与服务器上的资源一致时，才能说明缓存没有过期。</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一种面向连接、可靠的字节流通信协议，位于传输层中，具有顺序控制、重发控制、流量控制和拥塞控制等功能。<br>TCP进行数据传输的通信过程：  </p><ol><li>通过三次握手建立连接。</li><li>把发送窗口调整到合适的大小（避免网络拥塞，提高传输效率）。 </li><li>发出的每个包都会得到对面的确认。包丢失时可以执行超时重发；包乱序时可以根据序号按顺序排列；同时也能丢弃重复的包。</li><li>根据端口号将数据准确传送至通信中的应用程序。</li><li>待所有数据安全到达后，执行四次挥手断开连接。</li></ol><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>（二次握手不可靠，因为延迟等原因会建立无效的连接）：</p><ol><li>客户端发送一个携带SYN标志位的包，请求建立连接。</li><li>服务器响应一个携带SYN和ACK标志位的包，同意建立连接。</li><li>客户端再发送一个携带ACK标志位的包，表示连接成功，开始进行数据传输。</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol><li>客户端发送一个携带FIN标志位的包，请求断开连接。</li><li>服务器响应一个携带ACK标志位的包，同意客户断开连接。</li><li>服务器再发送一个携带FIN标志位的包，请求断开连接。</li><li>客户端最后发送一个携带ACK标志位的包，同意服务器断开连接。</li></ol><h3 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h3><ol><li>字段：Seq表示每个包的序号，用于排列乱序的包；Len表示数据的长度，不包括TCP头信息；Ack表示确认号，用于确认已经收到的字节。Seq等于上一个包中的Seq和Len的和；Ack等于对面发送过来的包中Seq和Len之和。通信两端会维护各自的Seq。</li><li>延迟确认：在一段时间内如果没有数据发送，就将几个确认信息合并成一个包再一起确认。</li><li>Nagle算法：发出的数据没有得到确认之前，又有几块小数据要发送，就把它们合并成一个包，再一起发送。</li></ol><p>延迟确认和Nagle都能够降低网络负担，提升传输效率，但不能结合使用。</p><h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><p>数据包所能携带的最大数据量称为MSS。当TCP传送大块数据的时候，会先将其分割为多个MSS再进行传输。MSS是发送数据包的单位，重发时也是以MSS为单位。在建立连接时，两端都会告诉对方自己所能接受的MSS的大小，然后选择一个较小的值投入使用。  </p><ol><li>发送窗口：控制一次能发的字节量，即一次能发MSS数量。阈值被称为拥塞点。</li><li>拥塞窗口：开始时通过慢启动对拥塞窗口进行控制；拥塞窗口的大小超过慢启动阈值时，改用拥塞避免方法。<br>拥塞窗口：在发送端设置一个窗口结构，根据网络的拥塞情况，动态调整该窗口大小，发送端只能发送大小小于滑动窗口和拥塞窗口的数据 </li></ol><h3 id="重传控制"><a href="#重传控制" class="headerlink" title="重传控制"></a>重传控制</h3><ol><li>超时重传：TCP会设定一个超时重传计数器（RTO），定义数据包从发出到失效的时间间隔。在这段时间内没有收到确认，就会重传这个包。超时重传严重降低传输性能，重传后还需要调整拥塞窗口。</li><li>快速重传：当发送方连续收到3个或3个以上对相同数据包的重复确认时，就会认为数据包丢失了并立即重发。  </li></ol><p>由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。 如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。<br><img src="//lyfflied.github.io/2019/08/25/计算机网络/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/img/DST856QXGMDJM38JBLQSOZV.png" alt="快速重传" title="快速重传">  </p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS是一种构建在SSL或TLS上的HTTP协议，是HTTP的安全版本。<br>TTP不安全的原因：  </p><ol><li>数据以明文传递，有被窃听的风险。</li><li>接收到的报文无法证明是发送时的报文，不能保障完整性，有被篡改的风险。</li><li>不验证通信两端的身份，请求或相应有被伪造的风险。</li></ol><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>HTTPS采用混合加密机制，将对称加密和非对称加密算法组合使用。交换公钥阶段使用非对称加密，传输报文阶段使用对称加密。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名由发送者生成的特殊加密校验码，用于确认报文的完整性，包括非对称加密和数字摘要（将变长的报文提取成定长的摘要，常用MD5和SHA）。<br>签名和校验的过程：  </p><ol><li>发送方用摘要算法对报文进行提取，生成一段摘要。</li><li>用私钥对摘要进行加密作为数字签名附在报文上，一起发送给接收方。</li><li>接收方收到报文后，用同样的摘要算法提取出摘要。</li><li>再用接收到的公钥对报文中的数字签名进行解密。</li><li>如果两个摘要相同，就证明报文没被篡改。</li></ol><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书相当于网络上的身份证，用于身份识别，内容包括有效期、颁发机构、颁发机构的签名、证书所有者的名称、证书所有者的公开密钥、版本号和唯一序列号等信息。</p><h3 id="安全通信机制"><a href="#安全通信机制" class="headerlink" title="安全通信机制"></a>安全通信机制</h3><ol><li>客户端发送Client Hello报文开始SSL通信，报文中还包括协议版本号、加密算法等信息。</li><li>服务器发送Server Hello报文作为应答，在报文中也会包括协议版本号、加密算法等信息。</li><li>服务器发送数字证书，数字证书中包含服务器的公开密钥。</li><li>客户端解开并验证数字证书，验证通过后，生成一个随机密码串，在用收到的服务器公钥加密，发送给服务器。</li><li>客户端再发送Change Cipher Spec报文，提示服务器在此条报文之后，采用刚刚生成的随机密码串进行数据加密。</li><li>服务器也发送Change Cipher Spec报文。</li><li>SSL连接建立完成，可以开始数据传输。</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>HTTP2.0是HTTP1.1的拓展版本，主要基于Google发布的SPDY协议，引入了全新的二进制分帧层。HTTP2.0的目标是优化应用，突破性能限制，改善用户在浏览Web页面时的速度体验。  </p><p><strong>HTTP1.1中5个有代表性的不足</strong>：  </p><ol><li>在传输中会出现首阻塞问题。</li><li>响应不分轻重缓急只会按先来后到的顺序执行。</li><li>并行通信需要建立多个TCP连接。</li><li>服务器不能主动推送客户端想要的资源，只能被动的等待客户端发起的请求。</li><li>由于HTTP是无状态的，所以每次请求和响应会携带大量冗余信息。</li></ol><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><p>二进制分帧层是HTTP2.0性能增强的关键，先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对接收帧拼成一条消息再处理请求。在HTTP2.0中，通信最小的单位为帧，若干帧组成一条消息，若干条消息在数据流中传输，一个TCP连接可以分出若干条数据流，因此只建立一次TCP连接就能完成所有传输。</p><h3 id="多路通信"><a href="#多路通信" class="headerlink" title="多路通信"></a>多路通信</h3><p>队首阻塞：TCP中途出现丢包，发送方会根据重发机制再发一次丢失的包，由于通信两端都是串行处理请求的，所以接收端在等待这个包到达之前，不会再处理后面的请求。<br>HTTP2.0不仅解决了队首阻塞问题，还将TCP建立次数降低到一次。通信两端只需将消息分解为独立的帧，然后在多条数据中乱序发送，最后在接收端把帧重新组合成消息，并且各条消息的组合互不干扰，实现真正意义上的并行通信，达到多路复用的效果。</p><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>在HTTP2.0中，每条数据流都有一个31位的优先值，值越小优先级越大，0的优先级最高。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP2.0支持服务器主动推送，一次请求返回多个响应，处理最初的请求外，还会额外推送客户端想要的资源。主动推送的资源可以缓存和压缩，客户端可以主动拒绝推送过来的资源。</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP2.0利用HPACK算法，让通信两端各自维护一张首部字典表（表中包含了首部名和首部值），对首部进行压缩，再进行传输。每次请求都会记住已发的首部，下一次只需传输不同的数据，相同的数据传索引即可。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue数据绑定与虚拟DOM</title>
      <link href="/2019/08/25/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2019/08/25/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="vue数据绑定"><a href="#vue数据绑定" class="headerlink" title="vue数据绑定"></a>vue数据绑定</h1><h4 id="单向绑定："><a href="#单向绑定：" class="headerlink" title="单向绑定："></a>单向绑定：</h4><p>把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。因此，我们不需要进行额外的DOM操作，只需要进行Model的操作就可以实现视图的联动更新。</p><h4 id="双向绑定："><a href="#双向绑定：" class="headerlink" title="双向绑定："></a>双向绑定：</h4><p>把Model绑定到View的同时也将View绑定到Model上，这样就既可以通过更新Model来实现View的自动更新，也可以通过更新View来实现Model数据的更新。所以，当我们用JavaScript代码更新Model时，View就会自动更新，反之，如果用户更新了View，Model的数据也自动被更新了。</p><h4 id="1-插值形式-（单向）"><a href="#1-插值形式-（单向）" class="headerlink" title="1. 插值形式   （单向）"></a>1. 插值形式   （单向）</h4><p>插值形式就是的形式，它使用的是单向绑定。</p><h4 id="2-v-bind形式-（单向）"><a href="#2-v-bind形式-（单向）" class="headerlink" title="2. v-bind形式 （单向）"></a>2. v-bind形式 （单向）</h4><p>如果我们希望html的某些属性能够支持单向绑定，我们只需要在该属性前面加上v-bind:指令，这样Vue在解析的时候会识别出该指令，就会将该将其属性的值跟Vue实例的Model进行绑定。这样我们就可以通过Model来动态的操作该属性从而实现DOM的联动更新。  </p><pre><code>&lt;p v-bind:class=&quot;classed&quot;&gt;</code></pre><h4 id="3-v-model-（双向）"><a href="#3-v-model-（双向）" class="headerlink" title="3. v-model （双向）"></a>3. v-model （双向）</h4><p>v-model主要是用在表单元素中，实现了双向绑定。<br>当用户填写表单时，View的状态就被更新了，如果此时Model的数据也会随着输入的数据动态的更新，那就相当于我们把Model和View做了双向绑定。  </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>vue的数据双向绑定是通过数据劫持结合发布者－订阅者模式来实现的<br>说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情． </p><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>当我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。<br>我们可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。<br>在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知。</p><p><strong>例子</strong></p><pre><code>var data = {name:&apos;lhl&apos;}Object.keys(data).forEach(function(key){    Object.defineProperty(data,key,{        enumerable:true, // 是否能在for...in循环中遍历出来或在Object.keys中列举出来。        configurable:true, // false，不可修改、删除目标属性或修改属性性以下特性        get:function(){            console.log(&apos;get&apos;);        },        set:function(){            console.log(&apos;监听到数据发生了变化&apos;);        }    })})；data.name //控制台会打印出 “get”data.name = &apos;hxx&apos; //控制台会打印出 &quot;监听到数据发生了变化&quot;</code></pre><h4 id="发布者-订阅者模式"><a href="#发布者-订阅者模式" class="headerlink" title="发布者-订阅者模式"></a>发布者-订阅者模式</h4><p>一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。  （跟关注微信公众号差不多）</p><h4 id="defineProperty方法"><a href="#defineProperty方法" class="headerlink" title="defineProperty方法"></a>defineProperty方法</h4><p>Object.defineProperty(obj,prop,descriptor)<br>obj: 要定义属性的对象<br>prop: 要定义或者修改的属性的名称<br>descriptor： 将被定义或修改的属性描述符<br>返回值：被传递给函数的对象。obj</p><pre><code>//在console.log(book.name)同时,直接给书加一个书号var Book = {};var name = &apos;&apos;;Object.defineProperty(Book,&apos;name&apos;,{    set:function(value) {        name = value;        console.log(&apos;你取了一个书名叫:&apos;+value);    },    get:function() {        console.log(&apos;get方法被监听到&apos;);        return &apos;&lt;&apos;+name+&apos;&gt;&apos;;    }});Book.name = &apos;人性的弱点&apos;;  //你取了一个书名叫:人性的弱点console.log(Book.name);　//&lt;人性的弱点&gt;</code></pre><p><strong>实现步骤：</strong><br>1.实现一个监听者Oberver来劫持并监听所有的属性，一旦有属性发生变化就通知订阅者  </p><p>2.实现一个订阅者watcher来接受属性变化的通知并执行相应的方法，从而更新视图  </p><p>3.实现一个解析器compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相对应的订阅者  </p><h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>其核心是基于两个简单的假设：</p><ol><li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。  </li><li>同一层级的一组节点，他们可以通过唯一的id进行区分。（如v-for 中的key）</li></ol><p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。</p><p><img src="//lyfflied.github.io/2019/08/25/Vue数据绑定与虚拟DOM/20190726vue_diff.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 数据绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件防抖与节流</title>
      <link href="/2019/08/25/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2019/08/25/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="事件的节流和防抖"><a href="#事件的节流和防抖" class="headerlink" title="事件的节流和防抖"></a>事件的节流和防抖</h2><p>有些浏览器事件可以在短时间内快速触发多次，比如调整窗口大小或向下滚动页面。例如，监听页面窗口滚动事件，并且用户持续快速地向下滚动页面，那么滚动事件可能在 3 秒内触发数千次，这可能会导致一些严重的性能问题。</p><p>如果在面试中讨论构建应用程序，出现滚动、窗口大小调整或按下键等事件请务必提及 防抖(Debouncing) 和 函数节流（Throttling）来提升页面速度和性能。这两兄弟的本质都是以闭包的形式存在。通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。  </p><h3 id="函节流抖：-第一个人说了算"><a href="#函节流抖：-第一个人说了算" class="headerlink" title="函节流抖： 第一个人说了算"></a>函节流抖： 第一个人说了算</h3><p>throttle 的主要思想在于：在某段时间内，不管你触发了多少次回调，都只认第一次，并在计时结束时给予响应。<br>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，<br>阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴<br>，持续触发scroll事件时，并不立即执行scroll，每隔1000毫秒才会执行一次scroll。</p><pre><code>// fn是我们需要包装的事件回调, interval是时间间隔的阈值function throttle(fn, interval) {  // last为上一次触发回调的时间  // 对比时间戳，初始化为0则首次触发立即执行，初始化为当前时间戳则wait毫秒后触发才会执行  let last = 0  // 将throttle处理结果当作函数返回  return function () {      // 保留调用时的this上下文      let context = this      // 保留调用时传入的参数      let args = arguments      // 记录本次触发回调的时间      let now = +new Date()      // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值      if (now - last &gt;= interval) {      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调          last = now;          fn.apply(context, args);      }    }}// 用throttle来包装scroll的回调const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)document.addEventListener(&apos;scroll&apos;, better_scroll)</code></pre><h3 id="函数防抖debounce：-最后一个说了算"><a href="#函数防抖debounce：-最后一个说了算" class="headerlink" title="函数防抖debounce： 最后一个说了算"></a>函数防抖debounce： 最后一个说了算</h3><p>防抖的主要思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。<br>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><pre><code>// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间function debounce(fn, delay) {  // 定时器  let timer = null  // 将debounce处理结果当作函数返回  return function () {    // 保留调用时的this上下文    let context = this    // 保留调用时传入的参数    let args = arguments    // 每次事件被触发时，都去清除之前的旧定时器    if(timer) {        clearTimeout(timer)    }    // 设立新定时器    timer = setTimeout(function () {      fn.apply(context, args)    }, delay)  }}// 用debounce来包装scroll的回调const better_scroll = debounce(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)document.addEventListener(&apos;scroll&apos;, better_scroll)</code></pre><h3 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h3><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。  </p><p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要delay的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：  </p><pre><code>// fn是我们需要包装的事件回调, delay是时间间隔的阈值function throttle(fn, delay) {  // last为上一次触发回调的时间, timer是定时器  let last = 0, timer = null  // 将throttle处理结果当作函数返回  return function () {     // 保留调用时的this上下文    let context = this    // 保留调用时传入的参数    let args = arguments    // 记录本次触发回调的时间    let now = +new Date()    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值    if (now - last &lt; delay) {    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器       clearTimeout(timer)       timer = setTimeout(function () {          last = now          fn.apply(context, args)        }, delay)    } else {        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应        last = now        fn.apply(context, args)    }  }}// 用新的throttle包装scroll的回调const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)document.addEventListener(&apos;scroll&apos;, better_scroll)</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。 这样一来，只有最后一次操作能被触发。</p><p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。<br>比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，<br> 而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2019/08/24/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/24/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><pre><code>$ hexo server或者$ hexo s</code></pre><p>访问URL： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>$ hexo clean$ hexo generate$ hexo deploy</code></pre><p>或者简写  </p><pre><code>$ hexo clean$ hexo g$ hexo d</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js拷贝与继承</title>
      <link href="/2019/08/24/js%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/08/24/js%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="浅拷贝和赋值"><a href="#浅拷贝和赋值" class="headerlink" title="浅拷贝和赋值"></a>浅拷贝和赋值</h2><p>对于对象，赋值是直接复制的指针，浅拷贝则是不能拷贝他下一层的对象（属性中的对象）</p><pre><code> var obj1 = {    &apos;name&apos; : &apos;zhangsan&apos;,    &apos;age&apos; :  &apos;18&apos;,    &apos;language&apos; : [1,[2,3],[4,5]],};var obj2 = obj1;var obj3 = shallowCopy(obj1);function shallowCopy(src) {    var dst = {};    for (var prop in src) {        if (src.hasOwnProperty(prop)) {            dst[prop] = src[prop];        }    }    return dst;}obj2.name = &quot;lisi&quot;;obj3.age = &quot;20&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];obj3.language[2] = [&quot;四&quot;,&quot;五&quot;];console.log(obj1);  //obj1 = {//    &apos;name&apos; : &apos;lisi&apos;,//    &apos;age&apos; :  &apos;18&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj2);//obj2 = {//    &apos;name&apos; : &apos;lisi&apos;,//    &apos;age&apos; :  &apos;18&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj3);//obj3 = {//    &apos;name&apos; : &apos;zhangsan&apos;,//    &apos;age&apos; :  &apos;20&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};</code></pre><p>赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><pre><code>//使用递归的方式实现数组、对象的深拷贝function deepClone1(obj) {  //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝  var objClone = Array.isArray(obj) ? [] : {};  //进行深拷贝的不能为空，并且是对象或者是  if (obj &amp;&amp; typeof obj === &quot;object&quot;) {    for (key in obj) {      if (obj.hasOwnProperty(key)) {        if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) {          objClone[key] = deepClone1(obj[key]);        } else {          objClone[key] = obj[key];        }      }    }  }  return objClone;}</code></pre><h3 id="2-通过JSON对象实现深拷贝"><a href="#2-通过JSON对象实现深拷贝" class="headerlink" title="2. 通过JSON对象实现深拷贝"></a>2. 通过JSON对象实现深拷贝</h3><pre><code>//通过js的内置对象JSON来进行数组对象的深拷贝function deepClone2(obj) {  var _obj = JSON.stringify(obj),//将JavaScript值转换为JSON字符串    objClone = JSON.parse(_obj);//将JSON字符串转为一个对象。  return objClone;}</code></pre><p>JSON对象实现深拷贝的一些问题<br>无法实现对对象中方法的深拷贝</p><h3 id="3-通过jQuery的extend方法实现深拷贝"><a href="#3-通过jQuery的extend方法实现深拷贝" class="headerlink" title="3. 通过jQuery的extend方法实现深拷贝"></a>3. 通过jQuery的extend方法实现深拷贝</h3><pre><code>var array = [1,2,3,4];var newArray = $.extend(true,[],array);</code></pre><p>jQuery.extend源码  </p><pre><code>jQuery.extend = jQuery.fn.extend = function() {    var src, copyIsArray, copy, name, options, clone,        target = arguments[0] || {},        i = 1,        length = arguments.length,        deep = false;    // Handle a deep copy situation    if ( typeof target === &quot;boolean&quot; ) {        deep = target;        // skip the boolean and the target        target = arguments[ i ] || {};        i++;    }    // Handle case when target is a string or something (possible in deep copy)    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {        target = {};    }    // extend jQuery itself if only one argument is passed    if ( i === length ) {        target = this;        i--;    }    for ( ; i &lt; length; i++ ) {        // Only deal with non-null/undefined values        if ( (options = arguments[ i ]) != null ) {            // Extend the base object            for ( name in options ) {                src = target[ name ];                copy = options[ name ];                // Prevent never-ending loop                if ( target === copy ) {                    continue;                }                // Recurse if we&apos;re merging plain objects or arrays                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {                    if ( copyIsArray ) {                        copyIsArray = false;                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];                    } else {                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};                    }                    // Never move original objects, clone them                    target[ name ] = jQuery.extend( deep, clone, copy );                // Don&apos;t bring in undefined values                } else if ( copy !== undefined ) {                    target[ name ] = copy;                }            }        }    }    // Return the modified object    return target;};</code></pre><h3 id="4-Object-assign-拷贝"><a href="#4-Object-assign-拷贝" class="headerlink" title="4. Object.assign()拷贝"></a>4. Object.assign()拷贝</h3><pre><code>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</code></pre><h3 id="5-lodash函数库实现深拷贝"><a href="#5-lodash函数库实现深拷贝" class="headerlink" title="5. lodash函数库实现深拷贝"></a>5. lodash函数库实现深拷贝</h3><pre><code>lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="1-类式继承"><a href="#1-类式继承" class="headerlink" title="1. 类式继承"></a>1. 类式继承</h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>将父类对象的实例赋值给子类的原型，则子类的原型可以访问父类原型上的属性和方法，以及父类构造函数中复制的属性和方法。</p><pre><code>//1。类式继承//声明父类function SuperClass(){    this.superValue = true;}//为父类添加公有方法SuperClass.prototype.getSuperValue = function(){    return this.superValue;};//声明子类function SubClass(){    this.subValue = false;}//继承父类SubClass.prototype = new SuperClass();//将父类对象赋值给子类原型，子类原型可以访问父类原型上的属性和方法 -- 类式继承原理//子类添加公有方法SubClass.prototype.getSubValue = function(){    return this.subValue;};  //测试var instance = new SubClass();console.log(instance.getSuperValue());//tconsole.log(instance.getSubValue());//f//console.log(instance instanceof SuperClass);//tconsole.log(instance instanceof SubClass);//tconsole.log(SubClass instanceof SuperClass);//fconsole.log(SubClass.prototype instanceof SuperClass);//t</code></pre><p>通过instanceof来检测某个对象是否是某个类的实例，<br>或者某个对象是否继承了某个类，这样可以判断对象和类之间的继承关系。<br>instanceof通过判断对象的prototype链来确定这个对象是否是某个类的实例。<br>需要注意的是，inatanceof是判断前面的对象是否是后面类（对象）的实例，并不表示两者的继承。<br>所以console.log(SubCass instanceof SuperClass)会打印出false，而console.log(SubClass.prototype instanceof SuperClass)才会打印出true。</p><h4 id="缺点（2个）"><a href="#缺点（2个）" class="headerlink" title="缺点（2个）"></a><strong>缺点（2个）</strong></h4><ol><li>子类通过其原型prototype对父类实例化，继承了父类。但当父类中的共有属性是引用类型时，会在子类中被所有的实例共用，如此在一个子类实例中更改从父类中继承过来的公有属性时，会影响到其他子类。</li></ol><pre><code>function SuperClass() {  this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];}function SubClass() {}SubClass.prototype = new SuperClass();var ins1 = new SubClass();var ins2 = new SubClass();console.log(ins1.book);console.log(ins2.book);ins1.book.push(&quot;Node&quot;);console.log(&quot;after&quot;);//引用类型在子类中被所有实例共用console.log(ins1.book);//[ &apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos; ]console.log(ins2.book);//[ &apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos; ]</code></pre><ol start="2"><li>由于子类是通过原型prototype实例化父类实现继承的，所以在创建父类的时候，无法向父类传递参数，因而在实例化父类的时候无法对父类构造函数内的属性初始化。</li></ol><h2 id="2-构造函数式继承"><a href="#2-构造函数式继承" class="headerlink" title="2. 构造函数式继承"></a>2. 构造函数式继承</h2><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>通过在子类的构造函数中执行一次父类的构造函数实现。</p><pre><code>//2.构造函数式继承//声明父类function SuperClass(id){    this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];//引用类型共有属性    this.id = id//值类型公有属性}//父类声明原型方法SuperClass.prototype.showBooks = function(){    console.log(this.books);}//声明子类function SubClass(id){    //继承父类    SuperClass.call(this,id);}//测试var ins1 = new SubClass(1);var ins2 = new SubClass(2);ins1.book.push(&quot;Node&quot;);console.log(ins1.id);//1console.log(ins1.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos;]console.log(ins2.id);//2console.log(ins2.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]ins1.showBooks();//TypeError: ins1.showBooks is not a function</code></pre><p>SuperClass.call(this,id)是构造函数式继承的中心。<br>call方法可以改变函数的作用环境，在子类中调用这个方法就是将子类中的变量在父类中执行，父类中给this绑定属性，因而子类继承了父类的共有属性。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种类型的继承没有涉及原型prototype，所以父类的原型方法不会被子类继承。<br>如想被子类继承就必须放在构造函数中(如books对象属性)，这样创造的每个实例都会单独拥有一份而不能共用，违背了代码复用原则。</p><h2 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3. 组合式继承"></a>3. 组合式继承</h2><h4 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h4><p>综合以上两种模式的优点，在子类原型上实例化父类，在子类构造函数中执行一边父类的构造函数。这样融合了类式继承和构造函数继承的优点，过滤了缺点。</p><pre><code>//3.组合式继承function SuperClass(name){    this.name = name;    this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];}SuperClass.prototype.getName = function () {console.log(this.name);};function SubClass(name,time){    //构造函数式继承，继承父类name属性    SuperClass.call(this,name);    this.time = time;}/类式继承，子类原型继承SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function () {console.log(this.time);};//测试var ins1 = new SubClass(&apos;Node&apos;,2016);ins1.book.push(&quot;Node&quot;);console.log(ins1.book);ins1.getName();ins1.getTime();var ins2 = new SubClass(&apos;React&apos;,2015);console.log(ins2.book);ins2.getName();ins2.getTime();</code></pre><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>父类的构造函数执行了两遍：一次在子类的构造函数中call方法执行一遍，一次在子类原型实例化父类的时候执行一遍。</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><h4 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h4><p>对类式继承的封装，过渡对象相当于子类</p><pre><code>//4.原型式继承funciton inheritObject(o){    //声明过度函数对象    function F(){}    //过渡对象的原型继承父类    F.prototype = o;    return new F();}//测试var book = {  name : &quot;javascript&quot;,  book : [&apos;js&apos;,&apos;css&apos;]};var newbook = inheritObject(book);newbook.name = &quot;ajax&quot;;newbook.book.push(&quot;Node&quot;);var otherbook = inheritObject(book);otherbook.name = &quot;xml&quot;;otherbook.book.push(&quot;React&quot;);console.log(newbook.name);//ajaxconsole.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(otherbook.name);//xmlconsole.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(book.name);//javascriptconsole.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</code></pre><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>和类式继承一样，父类对象的引用类型值被共用。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>寄生式继承其实是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了拓展。</p><pre><code>//5. 寄生式继承function inheritObject(o){    //声明过渡函数对象    function F(){}    //过渡对象的原型继承父类    F.prototype = o;    return new F();}//声明基对象var book ={    name: &apos;javaScript&apos;,    book: [&apos;js&apos;,&apos;css&apos;]};function createBook(obj){    //通过原型继承方式创建对象    var o = new inheritObject(obj);    //拓展新对象    o.getName = function(){        console.log(name);    }    //返回拓展后的新对象    return o;}var newbook = createBook(book);newbook.name = &quot;ajax&quot;;newbook.book.push(&quot;Node&quot;);var otherbook = createBook(book);otherbook.name = &quot;xml&quot;;otherbook.book.push(&quot;React&quot;);console.log(newbook.name);//ajaxconsole.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(otherbook.name);//xmlconsole.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(book.name);//javascriptconsole.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</code></pre><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>和类式继承一样，父类对象的引用类型值被共用。</p><h2 id="5-寄生组合式继承"><a href="#5-寄生组合式继承" class="headerlink" title="5. 寄生组合式继承"></a>5. 寄生组合式继承</h2><h4 id="简介：-3"><a href="#简介：-3" class="headerlink" title="简介："></a>简介：</h4><p>寄生式继承和构造函数式继承结合使用。</p><pre><code>//6. 寄生组合式继承function inheritObject(o){    //声明过度函数对象    function F(){}    //过度函数对象的原型继承父类    F.prototype = o;    return new F();}//寄生式继承 继承原型functioninheritPrototype(subClass,superClass){    //复制一份父类的原型副本保存在变量中    var p = inheritObject(superClass.prototype);    //修正因为重写子类原型导致子类的constructor属性被修改    p.constructor = subClass;    //设置子类的原型    subClass.prototype = p;}function SuperClass(name){    this.name = name;    this.colors = [&quot;red&quot;,&quot;bule&quot;];}//定义父类原型方法SuperClass.prototype.getName = function() {console.log(this.name);}function SubClass(name,time){    SuperClass.call(this,name);    this.time = time;}//寄生式继承父类原型inheritPrototype(SubClass,SuperClass);//子类新增原型方法SubClass.prototype.getTime = function() {  console.log(this.time);}//测试var ins1 = new SubClass(&quot;js&quot;,2014);var ins2 = new SubClass(&quot;css&quot;,2015);ins1.colors.push(&quot;black&quot;);console.log(ins1.colors);console.log(ins2.colors);ins2.getName();ins2.getTime();</code></pre><h2 id="6-混入方式继承多个方式"><a href="#6-混入方式继承多个方式" class="headerlink" title="6.混入方式继承多个方式"></a>6.混入方式继承多个方式</h2><h4 id="简介：-4"><a href="#简介：-4" class="headerlink" title="简介："></a>简介：</h4><p>利用Object.assign将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><pre><code>Object.assign(Child.prototype,Parent.prototype);Child.prototype.constructor = Child;</code></pre><h2 id="7-ES6类extends"><a href="#7-ES6类extends" class="headerlink" title="7.ES6类extends"></a>7.ES6类extends</h2><h4 id="简介：-5"><a href="#简介：-5" class="headerlink" title="简介："></a>简介：</h4><p>使用extends表明继承自哪个父类，并且在子类构造函数中必须使用super，可以看作是<br>Parent.call(this,value);</p><pre><code>Class Parent{    constructor(value){        this.val = value;    }}class Child extends Parent{    constructor(value){        super(value);        this.val = value;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
