<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js拷贝与继承</title>
      <link href="/2019/08/24/js%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/08/24/js%E6%8B%B7%E8%B4%9D%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="浅拷贝和赋值"><a href="#浅拷贝和赋值" class="headerlink" title="浅拷贝和赋值"></a>浅拷贝和赋值</h2><p>对于对象，赋值是直接复制的指针，浅拷贝则是不能拷贝他下一层的对象（属性中的对象）</p><pre><code> var obj1 = {    &apos;name&apos; : &apos;zhangsan&apos;,    &apos;age&apos; :  &apos;18&apos;,    &apos;language&apos; : [1,[2,3],[4,5]],};var obj2 = obj1;var obj3 = shallowCopy(obj1);function shallowCopy(src) {    var dst = {};    for (var prop in src) {        if (src.hasOwnProperty(prop)) {            dst[prop] = src[prop];        }    }    return dst;}obj2.name = &quot;lisi&quot;;obj3.age = &quot;20&quot;;obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];obj3.language[2] = [&quot;四&quot;,&quot;五&quot;];console.log(obj1);  //obj1 = {//    &apos;name&apos; : &apos;lisi&apos;,//    &apos;age&apos; :  &apos;18&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj2);//obj2 = {//    &apos;name&apos; : &apos;lisi&apos;,//    &apos;age&apos; :  &apos;18&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};console.log(obj3);//obj3 = {//    &apos;name&apos; : &apos;zhangsan&apos;,//    &apos;age&apos; :  &apos;20&apos;,//    &apos;language&apos; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//};</code></pre><p>赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><pre><code>//使用递归的方式实现数组、对象的深拷贝function deepClone1(obj) {  //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝  var objClone = Array.isArray(obj) ? [] : {};  //进行深拷贝的不能为空，并且是对象或者是  if (obj &amp;&amp; typeof obj === &quot;object&quot;) {    for (key in obj) {      if (obj.hasOwnProperty(key)) {        if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) {          objClone[key] = deepClone1(obj[key]);        } else {          objClone[key] = obj[key];        }      }    }  }  return objClone;}</code></pre><h3 id="2-通过JSON对象实现深拷贝"><a href="#2-通过JSON对象实现深拷贝" class="headerlink" title="2. 通过JSON对象实现深拷贝"></a>2. 通过JSON对象实现深拷贝</h3><pre><code>//通过js的内置对象JSON来进行数组对象的深拷贝function deepClone2(obj) {  var _obj = JSON.stringify(obj),//将JavaScript值转换为JSON字符串    objClone = JSON.parse(_obj);//将JSON字符串转为一个对象。  return objClone;}</code></pre><p>JSON对象实现深拷贝的一些问题<br>无法实现对对象中方法的深拷贝</p><h3 id="3-通过jQuery的extend方法实现深拷贝"><a href="#3-通过jQuery的extend方法实现深拷贝" class="headerlink" title="3. 通过jQuery的extend方法实现深拷贝"></a>3. 通过jQuery的extend方法实现深拷贝</h3><pre><code>var array = [1,2,3,4];var newArray = $.extend(true,[],array);</code></pre><p>jQuery.extend源码  </p><pre><code>jQuery.extend = jQuery.fn.extend = function() {    var src, copyIsArray, copy, name, options, clone,        target = arguments[0] || {},        i = 1,        length = arguments.length,        deep = false;    // Handle a deep copy situation    if ( typeof target === &quot;boolean&quot; ) {        deep = target;        // skip the boolean and the target        target = arguments[ i ] || {};        i++;    }    // Handle case when target is a string or something (possible in deep copy)    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {        target = {};    }    // extend jQuery itself if only one argument is passed    if ( i === length ) {        target = this;        i--;    }    for ( ; i &lt; length; i++ ) {        // Only deal with non-null/undefined values        if ( (options = arguments[ i ]) != null ) {            // Extend the base object            for ( name in options ) {                src = target[ name ];                copy = options[ name ];                // Prevent never-ending loop                if ( target === copy ) {                    continue;                }                // Recurse if we&apos;re merging plain objects or arrays                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {                    if ( copyIsArray ) {                        copyIsArray = false;                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];                    } else {                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};                    }                    // Never move original objects, clone them                    target[ name ] = jQuery.extend( deep, clone, copy );                // Don&apos;t bring in undefined values                } else if ( copy !== undefined ) {                    target[ name ] = copy;                }            }        }    }    // Return the modified object    return target;};</code></pre><h3 id="4-Object-assign-拷贝"><a href="#4-Object-assign-拷贝" class="headerlink" title="4. Object.assign()拷贝"></a>4. Object.assign()拷贝</h3><pre><code>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</code></pre><h3 id="5-lodash函数库实现深拷贝"><a href="#5-lodash函数库实现深拷贝" class="headerlink" title="5. lodash函数库实现深拷贝"></a>5. lodash函数库实现深拷贝</h3><pre><code>lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="1-类式继承"><a href="#1-类式继承" class="headerlink" title="1. 类式继承"></a>1. 类式继承</h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>将父类对象的实例赋值给子类的原型，则子类的原型可以访问父类原型上的属性和方法，以及父类构造函数中复制的属性和方法。</p><pre><code>//1。类式继承//声明父类function SuperClass(){    this.superValue = true;}//为父类添加公有方法SuperClass.prototype.getSuperValue = function(){    return this.superValue;};//声明子类function SubClass(){    this.subValue = false;}//继承父类SubClass.prototype = new SuperClass();//将父类对象赋值给子类原型，子类原型可以访问父类原型上的属性和方法 -- 类式继承原理//子类添加公有方法SubClass.prototype.getSubValue = function(){    return this.subValue;};  //测试var instance = new SubClass();console.log(instance.getSuperValue());//tconsole.log(instance.getSubValue());//f//console.log(instance instanceof SuperClass);//tconsole.log(instance instanceof SubClass);//tconsole.log(SubClass instanceof SuperClass);//fconsole.log(SubClass.prototype instanceof SuperClass);//t</code></pre><p>通过instanceof来检测某个对象是否是某个类的实例，<br>或者某个对象是否继承了某个类，这样可以判断对象和类之间的继承关系。<br>instanceof通过判断对象的prototype链来确定这个对象是否是某个类的实例。<br>需要注意的是，inatanceof是判断前面的对象是否是后面类（对象）的实例，并不表示两者的继承。<br>所以console.log(SubCass instanceof SuperClass)会打印出false，而console.log(SubClass.prototype instanceof SuperClass)才会打印出true。</p><h4 id="缺点（2个）"><a href="#缺点（2个）" class="headerlink" title="缺点（2个）"></a><strong>缺点（2个）</strong></h4><ol><li>子类通过其原型prototype对父类实例化，继承了父类。但当父类中的共有属性是引用类型时，会在子类中被所有的实例共用，如此在一个子类实例中更改从父类中继承过来的公有属性时，会影响到其他子类。</li></ol><pre><code>function SuperClass() {  this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];}function SubClass() {}SubClass.prototype = new SuperClass();var ins1 = new SubClass();var ins2 = new SubClass();console.log(ins1.book);console.log(ins2.book);ins1.book.push(&quot;Node&quot;);console.log(&quot;after&quot;);//引用类型在子类中被所有实例共用console.log(ins1.book);//[ &apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos; ]console.log(ins2.book);//[ &apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos; ]</code></pre><ol start="2"><li>由于子类是通过原型prototype实例化父类实现继承的，所以在创建父类的时候，无法向父类传递参数，因而在实例化父类的时候无法对父类构造函数内的属性初始化。</li></ol><h2 id="2-构造函数式继承"><a href="#2-构造函数式继承" class="headerlink" title="2. 构造函数式继承"></a>2. 构造函数式继承</h2><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>通过在子类的构造函数中执行一次父类的构造函数实现。</p><pre><code>//2.构造函数式继承//声明父类function SuperClass(id){    this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];//引用类型共有属性    this.id = id//值类型公有属性}//父类声明原型方法SuperClass.prototype.showBooks = function(){    console.log(this.books);}//声明子类function SubClass(id){    //继承父类    SuperClass.call(this,id);}//测试var ins1 = new SubClass(1);var ins2 = new SubClass(2);ins1.book.push(&quot;Node&quot;);console.log(ins1.id);//1console.log(ins1.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;Node&apos;]console.log(ins2.id);//2console.log(ins2.book);//[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;]ins1.showBooks();//TypeError: ins1.showBooks is not a function</code></pre><p>SuperClass.call(this,id)是构造函数式继承的中心。<br>call方法可以改变函数的作用环境，在子类中调用这个方法就是将子类中的变量在父类中执行，父类中给this绑定属性，因而子类继承了父类的共有属性。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种类型的继承没有涉及原型prototype，所以父类的原型方法不会被子类继承。<br>如想被子类继承就必须放在构造函数中(如books对象属性)，这样创造的每个实例都会单独拥有一份而不能共用，违背了代码复用原则。</p><h2 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3. 组合式继承"></a>3. 组合式继承</h2><h4 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h4><p>综合以上两种模式的优点，在子类原型上实例化父类，在子类构造函数中执行一边父类的构造函数。这样融合了类式继承和构造函数继承的优点，过滤了缺点。</p><pre><code>//3.组合式继承function SuperClass(name){    this.name = name;    this.book = [&apos;javascript&apos;,&apos;html&apos;,&apos;css&apos;];}SuperClass.prototype.getName = function () {console.log(this.name);};function SubClass(name,time){    //构造函数式继承，继承父类name属性    SuperClass.call(this,name);    this.time = time;}/类式继承，子类原型继承SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function () {console.log(this.time);};//测试var ins1 = new SubClass(&apos;Node&apos;,2016);ins1.book.push(&quot;Node&quot;);console.log(ins1.book);ins1.getName();ins1.getTime();var ins2 = new SubClass(&apos;React&apos;,2015);console.log(ins2.book);ins2.getName();ins2.getTime();</code></pre><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>父类的构造函数执行了两遍：一次在子类的构造函数中call方法执行一遍，一次在子类原型实例化父类的时候执行一遍。</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><h4 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h4><p>对类式继承的封装，过渡对象相当于子类</p><pre><code>//4.原型式继承funciton inheritObject(o){    //声明过度函数对象    function F(){}    //过渡对象的原型继承父类    F.prototype = o;    return new F();}//测试var book = {  name : &quot;javascript&quot;,  book : [&apos;js&apos;,&apos;css&apos;]};var newbook = inheritObject(book);newbook.name = &quot;ajax&quot;;newbook.book.push(&quot;Node&quot;);var otherbook = inheritObject(book);otherbook.name = &quot;xml&quot;;otherbook.book.push(&quot;React&quot;);console.log(newbook.name);//ajaxconsole.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(otherbook.name);//xmlconsole.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(book.name);//javascriptconsole.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</code></pre><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>和类式继承一样，父类对象的引用类型值被共用。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>寄生式继承其实是对原型继承的第二次封装，并且在第二次封装的过程中对继承的对象进行了拓展。</p><pre><code>//5. 寄生式继承function inheritObject(o){    //声明过渡函数对象    function F(){}    //过渡对象的原型继承父类    F.prototype = o;    return new F();}//声明基对象var book ={    name: &apos;javaScript&apos;,    book: [&apos;js&apos;,&apos;css&apos;]};function createBook(obj){    //通过原型继承方式创建对象    var o = new inheritObject(obj);    //拓展新对象    o.getName = function(){        console.log(name);    }    //返回拓展后的新对象    return o;}var newbook = createBook(book);newbook.name = &quot;ajax&quot;;newbook.book.push(&quot;Node&quot;);var otherbook = createBook(book);otherbook.name = &quot;xml&quot;;otherbook.book.push(&quot;React&quot;);console.log(newbook.name);//ajaxconsole.log(newbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(otherbook.name);//xmlconsole.log(otherbook.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]console.log(book.name);//javascriptconsole.log(book.book);//[ &apos;js&apos;, &apos;css&apos;, &apos;Node&apos;, &apos;React&apos; ]</code></pre><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>和类式继承一样，父类对象的引用类型值被共用。</p><h2 id="5-寄生组合式继承"><a href="#5-寄生组合式继承" class="headerlink" title="5. 寄生组合式继承"></a>5. 寄生组合式继承</h2><h4 id="简介：-3"><a href="#简介：-3" class="headerlink" title="简介："></a>简介：</h4><p>寄生式继承和构造函数式继承结合使用。</p><pre><code>//6. 寄生组合式继承function inheritObject(o){    //声明过度函数对象    function F(){}    //过度函数对象的原型继承父类    F.prototype = o;    return new F();}//寄生式继承 继承原型functioninheritPrototype(subClass,superClass){    //复制一份父类的原型副本保存在变量中    var p = inheritObject(superClass.prototype);    //修正因为重写子类原型导致子类的constructor属性被修改    p.constructor = subClass;    //设置子类的原型    subClass.prototype = p;}function SuperClass(name){    this.name = name;    this.colors = [&quot;red&quot;,&quot;bule&quot;];}//定义父类原型方法SuperClass.prototype.getName = function() {console.log(this.name);}function SubClass(name,time){    SuperClass.call(this,name);    this.time = time;}//寄生式继承父类原型inheritPrototype(SubClass,SuperClass);//子类新增原型方法SubClass.prototype.getTime = function() {  console.log(this.time);}//测试var ins1 = new SubClass(&quot;js&quot;,2014);var ins2 = new SubClass(&quot;css&quot;,2015);ins1.colors.push(&quot;black&quot;);console.log(ins1.colors);console.log(ins2.colors);ins2.getName();ins2.getTime();</code></pre><h2 id="6-混入方式继承多个方式"><a href="#6-混入方式继承多个方式" class="headerlink" title="6.混入方式继承多个方式"></a>6.混入方式继承多个方式</h2><h4 id="简介：-4"><a href="#简介：-4" class="headerlink" title="简介："></a>简介：</h4><p>利用Object.assign将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><pre><code>Object.assign(Child.prototype,Parent.prototype);Child.prototype.constructor = Child;</code></pre><h2 id="7-ES6类extends"><a href="#7-ES6类extends" class="headerlink" title="7.ES6类extends"></a>7.ES6类extends</h2><h4 id="简介：-5"><a href="#简介：-5" class="headerlink" title="简介："></a>简介：</h4><p>使用extends表明继承自哪个父类，并且在子类构造函数中必须使用super，可以看作是<br>Parent.call(this,value);</p><pre><code>Class Parent{    constructor(value){        this.val = value;    }}class Child extends Parent{    constructor(value){        super(value);        this.val = value;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello blog</title>
      <link href="/2019/08/24/blog/"/>
      <url>/2019/08/24/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是Hexo"><a href="#这是Hexo" class="headerlink" title="这是Hexo"></a>这是Hexo</h1><h3 id="ddd"><a href="#ddd" class="headerlink" title="ddd"></a>ddd</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/24/hello-world/"/>
      <url>/2019/08/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
